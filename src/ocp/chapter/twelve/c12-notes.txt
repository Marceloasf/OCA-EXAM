** Starts the 1Z0-816 and 1Z0-817 Chapters
** Chapter 12 - Java Fundamentals

* Java Fundamentals
  - Create and use final classes
  - Create and use inner, nested and anonymous classes
  - Create and use enumerations

* Java Interfaces
  - Create and use interfaces with default methods
  - Create and use interfaces with private methods

* Functional Interface and Lambda Expressions
  - Define and write functional interfaces
  - Create and use lambda expressions including statement lambdas, local-variable form lambda parameters

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** p.500-505
** Working with Enums
  - An enumeration (enum) is like a fixed set of constants. In Java, an enum, short for "enumerated type", can be a top-level type like 
  a class or interface, as well as a nested type like an inner class.
  - Using an enum is much better than using a bunch of constants because it provides type-safe checking. It is impossible to create an 
  invalid enum alue without introducing a compiler error.
  - To create a simple enum, just use the enum keyword instead of the class or interface keyword. Then list all the valid types for him:
    `
    public enum Season {
      WINTER, SPRING, SUMMER, FALL
    }
    `
  - Enum values are considered constans and are commonly written using snake case, often stylized as snake_case, using underscore to separate 
  words, like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE...
  - Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name(). 
    `
    Season s = Season.SUMMER;
    System.out.println(Season.SUMMER); // SUMMER
    System.out.println(s == Season.SUMMER); // true
    `
  - You can use equals() or == to compare enums, since each enum value is initialized only once in the Java Virtual Machine (JVM).
  - An enum provides a values() method to get an array of all of the values. You can use this like any normal array, including in an for-each loop.
  - Each enum value has a corresponding int value, in the order in which they are declared (starting from 0). You can get this value with enum.ordinal().
  - Even having a corresponding int value, you can't compare an int and enum value directly anyway, since an enum is a type like a Java class.
    `if (Season.SUMMER == 2) { }` // DOES NOT COMPILE
  - Its possible to retrieve an enum value from a String using the valueOf() method. The String passed in must match the enum value exactly.
    `
    Season s = Season.valueOf("SUMMER"); // SUMMER
    Season s = Season.valueOf("summer"); // Throws an exception at runtime
    `
  - Note that the first line isn't creating an enum value, at least not directly. Each enum value is created once when the enum is first loaded. Once it has 
  been loaded, it retrieves the single enum value with the matching name.
  - The second example will throw an IllegalArgumentException since there is no enum value with the lowercase name summer.
  - Two important rules about working with enums are:
    - Enums can't be extended by other enums, classes or interfaces.
    - Only the values in an enum are allowed, because you can't add more by extending an enum.

* Using Enums in Switch Statements
  - Remember that enum values can be used in switch statements.
  - The compiler already knows that the only possible matches can be enum values. So Java treats the enum type as implicit. In fact, if you try to type case 
  Season.WINTER or a primitive int, it would not compile. Example:
    `
    Season s = Season.SUMMER;
    switch(summer) {
      CASE SUMMER: 
        System.out.println("Time for the pool!");
        break;
      CASE SPRING: 
        System.out.println("Spring time!");
        break;
      CASE Season.WINTER:                       // DOES NOT COMPILE
        System.out.println("Rake some leaves!");
        break;
      CASE 0:                                   // DOES NOT COMPILE
        System.out.println("Get out the sled!");
      default:
        System.out.println("Is it summer yet?");
    }
    `
  - The first case statement that does not compile, is because Season is used in the case value, if we changed it to WINTER, then it would compile.
  - The second statement doesn't compile because you can't compare enums with int values, and you cannot use them in a switch case statement either.
  - So remember for the exam, enums can only be used with enums.

* Adding Constructors Fields and Methods
  - Enums can have more in them than just a list of values.
    * (Coded example on file Season.java)
  - A semicolon (;) is optional when our enum is composed solely of a list of values, but it is required if there is anything in the enum besides the values.
  - Marking instance variables of an enum with 'final' to make sure he is immutable is not required, but its considered a good coding practice to do so.

* Real World Scenario Notes:
  - The immutable objects pattern is an object-oriented design pattern in which an object cannot be modified after it is created. Instead of modifying an 
  immutable object, you create a new object that contains any properties from the original object you want copied over.
  - Immutable objects are invaluable in concurrent application since the state of the object cannot change or be corrupted by a rogue thread.

* Continuing Enums:
  - All enum constructors are implicitly private, with the modifier being optional.* This is reasonable since you can't extend an enum and the construtors 
  can be called only within the enum itself. An enum constrcutor will not compile if it contains a public or protected modifier.
  - To call a method inside an enum you just need to ask for the value and call the method, like `Season.SUMMER.printExpectedVisitors();`.
  - Notice how we don't appear to call the constructor. We just ask for the enum value. Because the first time that we ask for any of the enum values, Java 
  constructs all of the enum values. After that, Java just returns the already constructed enum values.
  - So remember that the constructor on an enum is called only once. Example:
    `
    public enum OnlyOne {
      ONCE(true);
      private OnlyOne(boolean b) {
        System.out.println("constructing,");
      }
    }
    (...)
    public statinc void main(String[] args) {
      System.out.println("begin,");
      OnlyOne firstCall = OnlyOne.ONCE; // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.println("end");
    } // This main() method prints 'begin,constructing,end'
    `
  - If the OnlyOne enum was used earlier, and therefore initialized sooner, then the line that declares the firstCall variable would not print anything.
  - We can let each enum value manage itself, like if they were a bunch of tiny subclasses.
    `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING {
        public String getHours() { return "9am-5pm"; }
      },
      SUMMER {
        public String getHours() { return "9am-7pm"; }
      };

      public abstract String getHours();
    }
    `
  - On this example, the enum itself has abstract method, which means that each and every enum value is required to implement this method. If we forget to 
  implement the mnethod for one of the values, then we get a compiler error.
  - Another way of implementing this is creating a default implementation and override it only for the special cases.
      `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING,
      SUMMER,
      FALL {
        public String getHours() { return "9am-7pm"; }
      };
      
      public String getHours() { return "9am-5pm"; }
    }
    `
  - Good practices reminder, try to keep your enums simple. If it has more than one page or two, its too long.
  - The compiler requires that the list of values in enums always be declared first, wheter the enum is simple or contains a ton of members.

** p.506-514
** Creating Nested Classes
  - A nested class is a class that is defined within another class.
  - Types of nested class:
    - Inner class: A non-static type defined at the member level of a class.
    - Static nested class: A static type defined at the member level of a class.
    - Local class: A class defined within a method body.
    - Anonymous class: A special case of a local class that does not have a name.
  - Nested classes can ecanpsulate helper classes byu restricting them to the containing class, can make it easy to create a class that will be used in only one place, 
  and can make the code cleaner and easier to read.
  - By convention, the term inner or nested class is used to apply to other Java types, including interfaces and enums. Because interfaces and enums can be declared as 
  both inner clases and static nested classes, but not as local or anonymous classes.
  - Inner classes can have inner classes, its not a good coding practice, but it may appear on the exam.

* Declaring an Inner Class:
  - Also known as a member inner class, is a non-static type defined at the member level of a class.
  - Inner classes have the following properties:
    - Can be declared public, protected, package-private (default) or private.
    - Can extend any class and implement interfaces.
    - Can be marked abstract or final.
    - Cannot declare static fields or methods, except for static final fields (constants).
    - Can access members of the outer class, including private members (even constructors).
  - You can instantiate an inner class from the parent class where its located, from a method for example. 
  - There is another way to instantiate it, for example:
    `
    public static void main(String[] args) {
      Outer outer = new Outer();
      Inner inner = outer.new Inner(); // create the inner class
      inner.go();
    }
    `
  - Basically, we need an instance of Outer to create Inner, we can't just call new Inner() because Java won't know with which insatnce of Outer it is associated. Java 
  solves this by calling new as if it were a method on the outer variable.
  - When a inner class is compiled, two files are created, one for the outer class and another for the inner class. Like this: Outer.class - Outer$Inner.class
  - Inner classes can have the same variable names as outer classes, making scope a little tricky. There is a special way of calling 'this' to say which variable you want:
    `
    public class A {
      private int x = 10;

      class B {
        private int x = 20;

        class C {
          private int x = 30;

          public void allTheX() {
            System.out.println(x); // 30
            System.out.println(this.x); // 30
            System.out.println(B.this.x); // 20
            System.out.println(A.this.x); // 10
          }
        }
      }
      public static void main(String... args) {
        A a = new A();
        A.B b = a.new B();
        A.B.C c = b.new C();
        c.allTheX(); 
      }
    }
    `
  - In fact, you are not limited to just one inner class. Please never do this in your code. But yes, you can nest multiple classes and access a variable with the same 
  name in each.
  - If we wanted, we could use B directly to instantiate because it is on the member level of the outer class, but C can't be used directly to instantiate, because C is 
  too deep for Java to know where to look.
  - Inner classes require an instance. Static methods can't access them, unless you're using an instance explicitly.
  - private inner classes can only be instantiated and accessed from within their outer class.

* Creating a static Nested Class:
  - A static nested class is a static type defined at the member level. 
  - Unlike an inner class, a static nested class can be instantiated without an instance of the enclosing class.
  - The trade-off is it can't access instance variables or methods in the outer class directly. It can be done, but requires an explicit reference to an outer class var.
  - In other words, it is like a top-level class, except for the following:
    - The nesting creates a namespace because the enclosing class name must be used to refer to it.
    - It can be made private or use one of the other access modifiers to ecanpsulate it.
    - The enclosing class can refer to the fields and methods of the static nested class.
  - Example of a static nested class:
    `
    public class Enclosing {
      static class Nested {
        private int price = 6;
      }

      public static void main(String[] args) {
        Nested nested = new Nested();
        System.out.println(nested.price); // You don't need an instance of Enclosing to use the Nested class, since the class is static.  
      }
    }
    `
  - You are allowed to access private instance variables from the static nested class.
  - Importing a static nested class has two ways of doing it, first you can import it using a regular import, and the other way is using a static import:
    - `import bird.Toucan.Beak;` 
    - `import static bird.Toucan.Beak;` 
      * Toucan is the enclosing class and Beak is the static inner class.
  - Remember that Java treats the enclosing class as if it were a namespace.

* Writing a Local Class:
  - A local class is a nested class defined within a METHOD. Like local variables, a local class declaration does not exist until the method is invoked, and it goes 
  out of scope when the method returns (ends).
  - You can create instance only from within the method, those instances can still be returned from the method.
  - They are not limited to being declared only inside methods. They can be declared inside constructors and initializers too.
  - They can be marked as final. 
  - Local classes have the folowing properties:
    - They do not have an access modifier.
    - They cannot be declared static and cannot declare static fields or methods, except for static final fields (constants).
    - They have access to all fields and methods of the enclosing class (when defined in an instance method).
    - They can access local variables if the variables are final or effectively final. *
      * As we saw earlier in lambdas, effectively final refers to a local variable whose value does not change after it is set (even if not marked final).
  - Why local variables need to be final or effectively final? Because the compiler is generating a .class file from your local class. A separate class has no way to 
  refer to local variables, so if the local variable is final, Java can handle it by passing it to the constructor of the local class or by storing it in the .class 
  file, if it weren't effectively final, these tricks wouldn't work because the value could change after the copy was made. An example of this:
    `
    public void processData() {
      final int length = 5;
      int width = 10;
      int height = 2;

      class VolumeCalculator {
        public int multiply() {
          return length * width * height; // DOES NOT COMPILE, because width value changes after is set.
        }
      } // Semicolon is optional for Local classes...

      width = 2;
    }
    `
* Defining an Anonymous Class:
  - An anonymous class is a specialized form of a local class that does not have a name. 
  - It is declared and instantiated all in one statement using the new keyword, a type name with parentheses and a set of braces {}.
  - Are required to extend an existing class or implement an existing interface.
  - They are useful when you have a short implementation that will not be used anywhere else.
  - Example of anonymous class extending a class:
    `
    public class ZooGiftShop {
      abstract class SaleTodayOnly {
        abstract int dollarsOff();
      }

      public int admission(int basePrice) {
        SaleTodayOnly sale = new SaleTodayOnly() {
          int dollarsOff() { return 3; }
        }; // Semicolon is required!

        return basePrice - sale.dollarsOff();
      }
    }
    ` 
  - Even SaleTodayOnly being abstract, we can instantiate her, because we are declaring the anonymous class body that extends her inside the braces.
  - Example of anonymous class implementing an interface:
    `
    public class ZooGiftShop {
      interface SaleTodayOnly {
        int dollarsOff();
      }

      public int admission(int basePrice) {
        SaleTodayOnly sale = new SaleTodayOnly() {
          public int dollarsOff() { return 3; }
        }; // Semicolon is required!

        return basePrice - sale.dollarsOff();
      }
    }
    `
  - You can notice how little it changed, the main difference is that the method dollarsOff() is required to be declared with public on the anonymous 
  class implementation. Since interfaces require public instead of default access.
  - Just remember that `SaleTodayOnly sale` that has been created is always an instance of a class instead of an interface.
  - You can't implement both an interface and extend a class with anonymous classes. 
  - So remember that an anonymous class is just an unnamed local class, you can write a local class and give it a name if you want to extend a class and implement 
  many interfaces.
  - You can define them right where they are needed, even if that is an argument to another method. Example:
    `
    public class ZooGiftShop {
      interface SaleTodayOnly {
        int dollarsOff();
      }

      public int pay() {
        return admission(5, new SaleTodayOnly() {
          public int dollarsOff() { return 3; }
        }); 
      }

      public int admission(int basePrice, SaleTodayOnly sale) {
        return basePrice - sale.dollarsOff();
      }
    }
    `
  - You can even define anonymous classes outside a method body. 
    `
    public class Gorilla {
      interface Climb {}
      Climb climbing = new Climb() { }; // Remember, we are not creating a reference to an interface instance, the { } indicates that we are creating a anonymous 
                                        // inner class that implements Climb interface.
    }
    `
  - Prior to Java 8, anonymous classes were frequently used for asynchronmous tasks and event handlers. For example an anonymous class being used as an event handler 
  in a JavaFX application:
    `
    Button redButton = new Button();
    redButton.setOnAction(new EventHandler<ActionEvent>() {
      public void handle(ActionEvent e) {
        System.out.println("Red button pressed!");
      }
    });
    `
  - Since Java 8, lambda expressions are a much more concise way of expressing the same thing:
    `
    Button redButton = new Button();
    redButton.setOnAction(e -> System.out.println("Red button pressed!"));
    `
  - The only restrictions when using anonymous classes and lambda expressions, is that the variable type must be a functional interface.

** p.515-516
** Reviewing Nested Classes
  - For the exam, you'll need to know about which syntax and access rules are permitted in Java on nested classes.
  - Modifiers in nested classes:
     ______________________________________________________________________________________________________
    |Permitted Modifiers    Inner class     static nested class        Local class         Anonymous class |
    |______________________________________________________________________________________________________|
    | Access modifiers      All             All                        None                None            |
    | abstract              Yes             Yes                        Yes                 No              |
    | final                 Yes             Yes                        Yes                 No              |
    |______________________________________________________________________________________________________|
  
  - Members in nested classes:
     _______________________________________________________________________________________________________
    |Permitted Members      Inner class     static nested class        Local class          Anonymous class |
    |_______________________________________________________________________________________________________|
    | Instance methods      Yes             Yes                        Yes                  Yes             |
    | Instance variables    Yes             Yes                        Yes                  Yes             |
    | static methods        No              Yes                        No                   No              |
    | static variables      Yes (if final)  Yes                        Yes (if final)       Yes (if final)  |
    |_______________________________________________________________________________________________________|
  
  - Nested class access rules:
     _______________________________________________________________________________________________________________________________________________________
    |Permitted Modifiers                    Inner class     static nested class        Local class                   Anonymous class                        |
    |_______________________________________________________________________________________________________________________________________________________|
    | Can extend any class or implement     Yes             Yes                        Yes                           No, must have exactly one superclass   |
    | any number of interfaces                                                                                       or one interface                       | 
    |_______________________________________________________________________________________________________________________________________________________|    
    | Can access instance members of        Yes             No                         Yes (if declared in an        Yes (if declared in an instance method)|     
    | enclosing class without a ref                                                    instance method)                                                     | 
    |_______________________________________________________________________________________________________________________________________________________|    
    | Can access local variables of         N/A             N/A                        Yes (if final or              Yes (if final or effectively final)    |
    | enclosing method                                                                 effectively final)                                                   |
    |_______________________________________________________________________________________________________________________________________________________|
