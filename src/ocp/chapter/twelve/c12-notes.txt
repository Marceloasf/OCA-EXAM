** Starts the 1Z0-816 and 1Z0-817 Chapters
** Chapter 12 - Java Fundamentals

* Java Fundamentals
  - Create and use final classes
  - Create and use inner, nested and anonymous classes
  - Create and use enumerations

* Java Interfaces
  - Create and use interfaces with default methods
  - Create and use interfaces with private methods

* Functional Interface and Lambda Expressions
  - Define and write functional interfaces
  - Create and use lambda expressions including statement lambdas, local-variable form lambda parameters

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** p.500-505
** Working with Enums
  - An enumeration (enum) is like a fixed set of constants. In Java, an enum, short for "enumerated type", can be a top-level type like 
  a class or interface, as well as a nested type like an inner class.
  - Using an enum is much better than using a bunch of constants because it provides type-safe checking. It is impossible to create an 
  invalid enum alue without introducing a compiler error.
  - To create a simple enum, just use the enum keyword instead of the class or interface keyword. Then list all the valid types for him:
    `
    public enum Season {
      WINTER, SPRING, SUMMER, FALL
    }
    `
  - Enum values are considered constans and are commonly written using snake case, often stylized as snake_case, using underscore to separate 
  words, like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE...
  - Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name(). 
    `
    Season s = Season.SUMMER;
    System.out.println(Season.SUMMER); // SUMMER
    System.out.println(s == Season.SUMMER); // true
    `
  - You can use equals() or == to compare enums, since each enum value is initialized only once in the Java Virtual Machine (JVM).
  - An enum provides a values() method to get an array of all of the values. You can use this like any normal array, including in an for-each loop.
  - Each enum value has a corresponding int value, in the order in which they are declared (starting from 0). You can get this value with enum.ordinal().
  - Even having a corresponding int value, you can't compare an int and enum value directly anyway, since an enum is a type like a Java class.
    `if (Season.SUMMER == 2) { }` // DOES NOT COMPILE
  - Its possible to retrieve an enum value from a String using the valueOf() method. The String passed in must match the enum value exactly.
    `
    Season s = Season.valueOf("SUMMER"); // SUMMER
    Season s = Season.valueOf("summer"); // Throws an exception at runtime
    `
  - Note that the first line isn't creating an enum value, at least not directly. Each enum value is created once when the enum is first loaded. Once it has 
  been loaded, it retrieves the single enum value with the matching name.
  - The second example will throw an IllegalArgumentException since there is no enum value with the lowercase name summer.
  - Two important rules about working with enums are:
    - Enums can't be extended by other enums, classes or interfaces.
    - Only the values in an enum are allowed, because you can't add more by extending an enum.

* Using Enums in Switch Statements
  - Remember that enum values can be used in switch statements.
  - The compiler already knows that the only possible matches can be enum values. So Java treats the enum type as implicit. In fact, if you try to type case 
  Season.WINTER or a primitive int, it would not compile. Example:
    `
    Season s = Season.SUMMER;
    switch(summer) {
      CASE SUMMER: 
        System.out.println("Time for the pool!");
        break;
      CASE SPRING: 
        System.out.println("Spring time!");
        break;
      CASE Season.WINTER:                       // DOES NOT COMPILE
        System.out.println("Rake some leaves!");
        break;
      CASE 0:                                   // DOES NOT COMPILE
        System.out.println("Get out the sled!");
      default:
        System.out.println("Is it summer yet?");
    }
    `
  - The first case statement that does not compile, is because Season is used in the case value, if we changed it to WINTER, then it would compile.
  - The second statement doesn't compile because you can't compare enums with int values, and you cannot use them in a switch case statement either.
  - So remember for the exam, enums can only be used with enums.

* Adding Constructors Fields and Methods
  - Enums can have more in them than just a list of values.
    * (Coded example on file Season.java)
  - A semicolon (;) is optional when our enum is composed solely of a list of values, but it is required if there is anything in the enum besides the values.
  - Marking instance variables of an enum with 'final' to make sure he is immutable is not required, but its considered a good coding practice to do so.

* Real World Scenario Notes:
  - The immutable objects pattern is an object-oriented design pattern in which an object cannot be modified after it is created. Instead of modifying an 
  immutable object, you create a new object that contains any properties from the original object you want copied over.
  - Immutable objects are invaluable in concurrent application since the state of the object cannot change or be corrupted by a rogue thread.

* Continuing Enums:
  - All enum constructors are implicitly private, with the modifier being optional.* This is reasonable since you can't extend an enum and the construtors 
  can be called only within the enum itself. An enum constrcutor will not compile if it contains a public or protected modifier.
  - To call a method inside an enum you just need to ask for the value and call the method, like `Season.SUMMER.printExpectedVisitors();`.
  - Notice how we don't appear to call the constructor. We just ask for the enum value. Because the first time that we ask for any of the enum values, Java 
  constructs all of the enum values. After that, Java just returns the already constructed enum values.
  - So remember that the constructor on an enum is called only once. Example:
    `
    public enum OnlyOne {
      ONCE(true);
      private OnlyOne(boolean b) {
        System.out.println("constructing,");
      }
    }
    (...)
    public statinc void main(String[] args) {
      System.out.println("begin,");
      OnlyOne firstCall = OnlyOne.ONCE; // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.println("end");
    } // This main() method prints 'begin,constructing,end'
    `
  - If the OnlyOne enum was used earlier, and therefore initialized sooner, then the line that declares the firstCall variable would not print anything.
  - We can let each enum value manage itself, like if they were a bunch of tiny subclasses.
    `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING {
        public String getHours() { return "9am-5pm"; }
      },
      SUMMER {
        public String getHours() { return "9am-7pm"; }
      };

      public abstract String getHours();
    }
    `
  - On this example, the enum itself has abstract method, which means that each and every enum value is required to implement this method. If we forget to 
  implement the mnethod for one of the values, then we get a compiler error.
  - Another way of implementing this is creating a default implementation and override it only for the special cases.
      `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING,
      SUMMER,
      FALL {
        public String getHours() { return "9am-7pm"; }
      };
      
      public String getHours() { return "9am-5pm"; }
    }
    `
  - Good practices reminder, try to keep your enums simple. If it has more than one page or two, its too long.
  - The compiler requires that the list of values in enums always be declared first, wheter the enum is simple or contains a ton of members.

** p.506
** Creating Nested Classes
  - A nested class is a class that is defined within another class.
  - Types of nested class:
    - Inner class: A non-static type defined at the member level of a class.
    - Static nested class: A static type defined at the member level of a class.
    - Local class: A class defined within a method body.
    - Anonymous class: A special case of a local class that does not have a name.
  - Nested classes can ecanpsulate helper classes byu restricting them to the containing class, can make it easy to create a class that will be used in only one place, 
  and can make the code cleaner and easier to read.
  - By convention, the term inner or nested class is used to apply to other Java types, including interfaces and enums. Because interfaces and enums can be declared as 
  both inner clases and static nested classes, but not as local or anonymous classes.
  - Inner classes can have inner classes, its not a good coding practice, but it may appear on the exam.
  