** Starts the 1Z0-816 and 1Z0-817 Chapters
** Chapter 12 - Java Fundamentals

* Java Fundamentals
  - Create and use final classes
  - Create and use inner, nested and anonymous classes
  - Create and use enumerations

* Java Interfaces
  - Create and use interfaces with default methods
  - Create and use interfaces with private methods

* Functional Interface and Lambda Expressions
  - Define and write functional interfaces
  - Create and use lambda expressions including statement lambdas, local-variable form lambda parameters

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** p.500-505
** Working with Enums
  - An enumeration (enum) is like a fixed set of constants. In Java, an enum, short for "enumerated type", can be a top-level type like 
  a class or interface, as well as a nested type like an inner class.
  - Using an enum is much better than using a bunch of constants because it provides type-safe checking. It is impossible to create an 
  invalid enum alue without introducing a compiler error.
  - To create a simple enum, just use the enum keyword instead of the class or interface keyword. Then list all the valid types for him:
    `
    public enum Season {
      WINTER, SPRING, SUMMER, FALL
    }
    `
  - Enum values are considered constans and are commonly written using snake case, often stylized as snake_case, using underscore to separate 
  words, like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE...
  - Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name(). 
    `
    Season s = Season.SUMMER;
    System.out.println(Season.SUMMER); // SUMMER
    System.out.println(s == Season.SUMMER); // true
    `
  - You can use equals() or == to compare enums, since each enum value is initialized only once in the Java Virtual Machine (JVM).
  - An enum provides a values() method to get an array of all of the values. You can use this like any normal array, including in an for-each loop.
  - Each enum value has a corresponding int value, in the order in which they are declared (starting from 0). You can get this value with enum.ordinal().
  - Even having a corresponding int value, you can't compare an int and enum value directly anyway, since an enum is a type like a Java class.
    `if (Season.SUMMER == 2) { }` // DOES NOT COMPILE
  - Its possible to retrieve an enum value from a String using the valueOf() method. The String passed in must match the enum value exactly.
    `
    Season s = Season.valueOf("SUMMER"); // SUMMER
    Season s = Season.valueOf("summer"); // Throws an exception at runtime
    `
  - Note that the first line isn't creating an enum value, at least not directly. Each enum value is created once when the enum is first loaded. Once it has 
  been loaded, it retrieves the single enum value with the matching name.
  - The second example will throw an IllegalArgumentException since there is no enum value with the lowercase name summer.
  - Two important rules about working with enums are:
    - Enums can't be extended by other enums, classes or interfaces.
    - Only the values in an enum are allowed, because you can't add more by extending an enum.

* Using Enums in Switch Statements
  - Remember that enum values can be used in switch statements.
  - The compiler already knows that the only possible matches can be enum values. So Java treats the enum type as implicit. In fact, if you try to type case 
  Season.WINTER or a primitive int, it would not compile. Example:
    `
    Season s = Season.SUMMER;
    switch(summer) {
      CASE SUMMER: 
        System.out.println("Time for the pool!");
        break;
      CASE SPRING: 
        System.out.println("Spring time!");
        break;
      CASE Season.WINTER:                       // DOES NOT COMPILE
        System.out.println("Rake some leaves!");
        break;
      CASE 0:                                   // DOES NOT COMPILE
        System.out.println("Get out the sled!");
      default:
        System.out.println("Is it summer yet?");
    }
    `
  - The first case statement that does not compile, is because Season is used in the case value, if we changed it to WINTER, then it would compile.
  - The second statement doesn't compile because you can't compare enums with int values, and you cannot use them in a switch case statement either.
  - So remember for the exam, enums can only be used with enums.

* Adding Constructors Fields and Methods
  - Enums can have more in them than just a list of values.
    * (Coded example on file Season.java)
  - A semicolon (;) is optional when our enum is composed solely of a list of values, but it is required if there is anything in the enum besides the values.
  - Marking instance variables of an enum with 'final' to make sure he is immutable is not required, but its considered a good coding practice to do so.

* Real World Scenario Notes:
  - The immutable objects pattern is an object-oriented design pattern in which an object cannot be modified after it is created. Instead of modifying an 
  immutable object, you create a new object that contains any properties from the original object you want copied over.
  - Immutable objects are invaluable in concurrent application since the state of the object cannot change or be corrupted by a rogue thread.

* Continuing Enums:
  - All enum constructors are implicitly private, with the modifier being optional.* This is reasonable since you can't extend an enum and the construtors 
  can be called only within the enum itself. An enum constrcutor will not compile if it contains a public or protected modifier.
  - To call a method inside an enum you just need to ask for the value and call the method, like `Season.SUMMER.printExpectedVisitors();`.
  - Notice how we don't appear to call the constructor. We just ask for the enum value. Because the first time that we ask for any of the enum values, Java 
  constructs all of the enum values. After that, Java just returns the already constructed enum values.
  - So remember that the constructor on an enum is called only once. Example:
    `
    public enum OnlyOne {
      ONCE(true);
      private OnlyOne(boolean b) {
        System.out.println("constructing,");
      }
    }
    (...)
    public statinc void main(String[] args) {
      System.out.println("begin,");
      OnlyOne firstCall = OnlyOne.ONCE; // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.println("end");
    } // This main() method prints 'begin,constructing,end'
    `
  - If the OnlyOne enum was used earlier, and therefore initialized sooner, then the line that declares the firstCall variable would not print anything.
  - We can let each enum value manage itself, like if they were a bunch of tiny subclasses.
    `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING {
        public String getHours() { return "9am-5pm"; }
      },
      SUMMER {
        public String getHours() { return "9am-7pm"; }
      };

      public abstract String getHours();
    }
    `
  - On this example, the enum itself has abstract method, which means that each and every enum value is required to implement this method. If we forget to 
  implement the mnethod for one of the values, then we get a compiler error.
  - Another way of implementing this is creating a default implementation and override it only for the special cases.
      `
    public enum Season {
      WINTER {
        public String getHours() { return "9am-3pm"; }
      },
      SPRING,
      SUMMER,
      FALL {
        public String getHours() { return "9am-7pm"; }
      };
      
      public String getHours() { return "9am-5pm"; }
    }
    `
  - Good practices reminder, try to keep your enums simple. If it has more than one page or two, its too long.
  - The compiler requires that the list of values in enums always be declared first, wheter the enum is simple or contains a ton of members.

** p.506-514
** Creating Nested Classes
  - A nested class is a class that is defined within another class.
  - Types of nested class:
    - Inner class: A non-static type defined at the member level of a class.
    - Static nested class: A static type defined at the member level of a class.
    - Local class: A class defined within a method body.
    - Anonymous class: A special case of a local class that does not have a name.
  - Nested classes can ecanpsulate helper classes byu restricting them to the containing class, can make it easy to create a class that will be used in only one place, 
  and can make the code cleaner and easier to read.
  - By convention, the term inner or nested class is used to apply to other Java types, including interfaces and enums. Because interfaces and enums can be declared as 
  both inner clases and static nested classes, but not as local or anonymous classes.
  - Inner classes can have inner classes, its not a good coding practice, but it may appear on the exam.

* Declaring an Inner Class:
  - Also known as a member inner class, is a non-static type defined at the member level of a class.
  - Inner classes have the following properties:
    - Can be declared public, protected, package-private (default) or private.
    - Can extend any class and implement interfaces.
    - Can be marked abstract or final.
    - Cannot declare static fields or methods, except for static final fields (constants).
    - Can access members of the outer class, including private members (even constructors).
  - You can instantiate an inner class from the parent class where its located, from a method for example. 
  - There is another way to instantiate it, for example:
    `
    public static void main(String[] args) {
      Outer outer = new Outer();
      Inner inner = outer.new Inner(); // create the inner class
      inner.go();
    }
    `
  - Basically, we need an instance of Outer to create Inner, we can't just call new Inner() because Java won't know with which insatnce of Outer it is associated. Java 
  solves this by calling new as if it were a method on the outer variable.
  - When a inner class is compiled, two files are created, one for the outer class and another for the inner class. Like this: Outer.class - Outer$Inner.class
  - Inner classes can have the same variable names as outer classes, making scope a little tricky. There is a special way of calling 'this' to say which variable you want:
    `
    public class A {
      private int x = 10;

      class B {
        private int x = 20;

        class C {
          private int x = 30;

          public void allTheX() {
            System.out.println(x); // 30
            System.out.println(this.x); // 30
            System.out.println(B.this.x); // 20
            System.out.println(A.this.x); // 10
          }
        }
      }
      public static void main(String... args) {
        A a = new A();
        A.B b = a.new B();
        A.B.C c = b.new C();
        c.allTheX(); 
      }
    }
    `
  - In fact, you are not limited to just one inner class. Please never do this in your code. But yes, you can nest multiple classes and access a variable with the same 
  name in each.
  - If we wanted, we could use B directly to instantiate because it is on the member level of the outer class, but C can't be used directly to instantiate, because C is 
  too deep for Java to know where to look.
  - Inner classes require an instance. Static methods can't access them, unless you're using an instance explicitly.
  - private inner classes can only be instantiated and accessed from within their outer class.

* Creating a static Nested Class:
  - A static nested class is a static type defined at the member level. 
  - Unlike an inner class, a static nested class can be instantiated without an instance of the enclosing class.
  - The trade-off is it can't access instance variables or methods in the outer class directly. It can be done, but requires an explicit reference to an outer class var.
  - In other words, it is like a top-level class, except for the following:
    - The nesting creates a namespace because the enclosing class name must be used to refer to it.
    - It can be made private or use one of the other access modifiers to ecanpsulate it.
    - The enclosing class can refer to the fields and methods of the static nested class.
  - Example of a static nested class:
    `
    public class Enclosing {
      static class Nested {
        private int price = 6;
      }

      public static void main(String[] args) {
        Nested nested = new Nested();
        System.out.println(nested.price); // You don't need an instance of Enclosing to use the Nested class, since the class is static.  
      }
    }
    `
  - You are allowed to access private instance variables from the static nested class.
  - Importing a static nested class has two ways of doing it, first you can import it using a regular import, and the other way is using a static import:
    - `import bird.Toucan.Beak;` 
    - `import static bird.Toucan.Beak;` 
      * Toucan is the enclosing class and Beak is the static inner class.
  - Remember that Java treats the enclosing class as if it were a namespace.

* Writing a Local Class:
  - A local class is a nested class defined within a METHOD. Like local variables, a local class declaration does not exist until the method is invoked, and it goes 
  out of scope when the method returns (ends).
  - You can create instance only from within the method, those instances can still be returned from the method.
  - They are not limited to being declared only inside methods. They can be declared inside constructors and initializers too.
  - They can be marked as final. 
  - Local classes have the folowing properties:
    - They do not have an access modifier.
    - They cannot be declared static and cannot declare static fields or methods, except for static final fields (constants).
    - They have access to all fields and methods of the enclosing class (when defined in an instance method).
    - They can access local variables if the variables are final or effectively final. *
      * As we saw earlier in lambdas, effectively final refers to a local variable whose value does not change after it is set (even if not marked final).
  - Why local variables need to be final or effectively final? Because the compiler is generating a .class file from your local class. A separate class has no way to 
  refer to local variables, so if the local variable is final, Java can handle it by passing it to the constructor of the local class or by storing it in the .class 
  file, if it weren't effectively final, these tricks wouldn't work because the value could change after the copy was made. An example of this:
    `
    public void processData() {
      final int length = 5;
      int width = 10;
      int height = 2;

      class VolumeCalculator {
        public int multiply() {
          return length * width * height; // DOES NOT COMPILE, because width value changes after is set.
        }
      } // Semicolon is optional for Local classes...

      width = 2;
    }
    `
* Defining an Anonymous Class:
  - An anonymous class is a specialized form of a local class that does not have a name. 
  - It is declared and instantiated all in one statement using the new keyword, a type name with parentheses and a set of braces {}.
  - Are required to extend an existing class or implement an existing interface.
  - They are useful when you have a short implementation that will not be used anywhere else.
  - Example of anonymous class extending a class:
    `
    public class ZooGiftShop {
      abstract class SaleTodayOnly {
        abstract int dollarsOff();
      }

      public int admission(int basePrice) {
        SaleTodayOnly sale = new SaleTodayOnly() {
          int dollarsOff() { return 3; }
        }; // Semicolon is required!

        return basePrice - sale.dollarsOff();
      }
    }
    ` 
  - Even SaleTodayOnly being abstract, we can instantiate her, because we are declaring the anonymous class body that extends her inside the braces.
  - Example of anonymous class implementing an interface:
    `
    public class ZooGiftShop {
      interface SaleTodayOnly {
        int dollarsOff();
      }

      public int admission(int basePrice) {
        SaleTodayOnly sale = new SaleTodayOnly() {
          public int dollarsOff() { return 3; }
        }; // Semicolon is required!

        return basePrice - sale.dollarsOff();
      }
    }
    `
  - You can notice how little it changed, the main difference is that the method dollarsOff() is required to be declared with public on the anonymous 
  class implementation. Since interfaces require public instead of default access.
  - Just remember that `SaleTodayOnly sale` that has been created is always an instance of a class instead of an interface.
  - You can't implement both an interface and extend a class with anonymous classes. 
  - So remember that an anonymous class is just an unnamed local class, you can write a local class and give it a name if you want to extend a class and implement 
  many interfaces.
  - You can define them right where they are needed, even if that is an argument to another method. Example:
    `
    public class ZooGiftShop {
      interface SaleTodayOnly {
        int dollarsOff();
      }

      public int pay() {
        return admission(5, new SaleTodayOnly() {
          public int dollarsOff() { return 3; }
        }); 
      }

      public int admission(int basePrice, SaleTodayOnly sale) {
        return basePrice - sale.dollarsOff();
      }
    }
    `
  - You can even define anonymous classes outside a method body. 
    `
    public class Gorilla {
      interface Climb {}
      Climb climbing = new Climb() { }; // Remember, we are not creating a reference to an interface instance, the { } indicates that we are creating a anonymous 
                                        // inner class that implements Climb interface.
    }
    `
  - Prior to Java 8, anonymous classes were frequently used for asynchronmous tasks and event handlers. For example an anonymous class being used as an event handler 
  in a JavaFX application:
    `
    Button redButton = new Button();
    redButton.setOnAction(new EventHandler<ActionEvent>() {
      public void handle(ActionEvent e) {
        System.out.println("Red button pressed!");
      }
    });
    `
  - Since Java 8, lambda expressions are a much more concise way of expressing the same thing:
    `
    Button redButton = new Button();
    redButton.setOnAction(e -> System.out.println("Red button pressed!"));
    `
  - The only restrictions when using anonymous classes and lambda expressions, is that the variable type must be a functional interface.

** p.515-516
** Reviewing Nested Classes
  - For the exam, you'll need to know about which syntax and access rules are permitted in Java on nested classes.
  - Modifiers in nested classes:
     ______________________________________________________________________________________________________
    |Permitted Modifiers    Inner class     static nested class        Local class         Anonymous class |
    |______________________________________________________________________________________________________|
    | Access modifiers      All             All                        None                None            |
    | abstract              Yes             Yes                        Yes                 No              |
    | final                 Yes             Yes                        Yes                 No              |
    |______________________________________________________________________________________________________|
  
  - Members in nested classes:
     _______________________________________________________________________________________________________
    |Permitted Members      Inner class     static nested class        Local class          Anonymous class |
    |_______________________________________________________________________________________________________|
    | Instance methods      Yes             Yes                        Yes                  Yes             |
    | Instance variables    Yes             Yes                        Yes                  Yes             |
    | static methods        No              Yes                        No                   No              |
    | static variables      Yes (if final)  Yes                        Yes (if final)       Yes (if final)  |
    |_______________________________________________________________________________________________________|
  
  - Nested class access rules:
     _______________________________________________________________________________________________________________________________________________________
    |Permitted Modifiers                    Inner class     static nested class        Local class                   Anonymous class                        |
    |_______________________________________________________________________________________________________________________________________________________|
    | Can extend any class or implement     Yes             Yes                        Yes                           No, must have exactly one superclass   |
    | any number of interfaces                                                                                       or one interface                       | 
    |_______________________________________________________________________________________________________________________________________________________|    
    | Can access instance members of        Yes             No                         Yes (if declared in an        Yes (if declared in an instance method)|     
    | enclosing class without a ref                                                    instance method)                                                     | 
    |_______________________________________________________________________________________________________________________________________________________|    
    | Can access local variables of         N/A             N/A                        Yes (if final or              Yes (if final or effectively final)    |
    | enclosing method                                                                 effectively final)                                                   |
    |_______________________________________________________________________________________________________________________________________________________|

** p.516-526
** Understanding Interface Members
  - When Java first release, there were only two types of members an interface declaration could include: abstract methods and constant (static final) variables.
  Since Java 8 and 9, four new method types have been added that will be covered in this section.
     _______________________________________________________________________________________________________________________________________________
    |                         Since Java version      Membership type            Required modifiers     Implicit modifiers      Has value or body?  |
    |_______________________________________________________________________________________________________________________________________________|
    | Constant variable       1.0                     Class                      -                      public static final     Yes                 |                      
    | Abstract method         1.0                     Instance                   -                      public abstract         No                  |                     
    | Default method          8                       Instance                   default                public                  Yes                 |                      
    | Static method           8                       Class                      static                 public                  Yes                 |                      
    | Private method          9                       Instance                   private                -                       Yes                 |                      
    | Private static method   9                       Class                      private static         -                       Yes                 |                      
    |_______________________________________________________________________________________________________________________________________________|
  - This section will cover the newer interface member types, because the constant variables and abstract methods were covered before.

** Relying on a default Interface Method
  - A default method is a method defined in an interface with the default keyword and includes a method body.
  - May be overriden by a class implementing the interface. The class has the option of overriding the default method, but if it does not, then the default 
  implementation will be used.
  - The modifier name 'default' comes from the concept that it is viewed as an abstract interface method with a default implementation (has no relation with both the switch 
  default and default (package-private) access modifier).
  - Must be overriden using the public access modifier (is implicitly added on the interface), a different access modifier is not allowed. 
  - Default method implementation example:
    `
    public interface IsWarmBlooded {
      boolean hasScales(); // abstract method - concrete class must implement
      default double getTemperature() { // default method - concrete class may implement
        return 10.0;
      }
    }
    `
  - Default Interface Method Definition Rules:
    1. A default method may be declared only within an interface.
    2. A default method must be marked with the default keyword and include a method body.
    3. A default method is assumed to be public.
    4. A default method cannot be marked abstract, final or static.
    5. A default method may be overriden by a class that implements the interface.
    6. If a class inherits two or more default methods with the same method signature, then the class must override the method.
* Rule six discussion (duplicate inherited default methods):
  - Rule six will make the compiler report an error on the class declaration line, unless the method has been overriden.
  - This rule holds true even for abstract classes because the duplicate method could be called within a concrete method within the abstract class.
  - These rules also apply to methods with the same signature but different return types or declared exceptions.
  - By overriding the conflicting method, the ambiguity about which version of the method to call is removed.
  - If a default method is overridden in the concrete class, then it must use a declaration that is compatible, following the rules for overriding methods.
* Calling a Hidden Default Method:
  - super.method() can't be used with interface methods, since an interface is not part of the class hierarchy.
  - When you have two default methods on two distinct interfaces and that a class implements both, this is where a default method exhibits properites of both a static 
  and a instance method. For example:
    `
    public class Cat implements Walk, Run {
      public int getSpeed() {
        return 1;
      }

      public int getWalkSpeed() {
        return Walk.super.getSpeed(); // This is how you call one of the default implementations, not with super.getSpeed() or Walk.getSpeed().
      }

      public static void main(String[] args) {
        System.out.print(new Cat().getWalkSpeed());
      }
    }
    `
  - First we use the interface name, followed by the super keyword, followed by the default method we want to call.
  - super call to the default method is placed inside a instance method, as super is not accessible in the main method.
  - Remember for the exam, default methods may only be declared within interfaces.

** Using static Interface Methods
  - These methods are defined EXPLICITLY with the static keyword and for the most part behave just like static methods defined in classes.
  - Static Interface Method Definition Rules:
    1. A static method must be marked with the static keyword and include a method body.
    2. A static method without an access modifier is assumed to be public.
    3. A static method cannot be marked abstract or final.
    4. A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.
  - Static interface method example:
    `
    public interface Hop {
      static int getJumpHeight() {
        return 8;
      }
    }
    `
  - Works just like a static method as defined in a class. So it can be accessed without an instance of a class using the Hop.getJumpHeight() syntax.
  - Remember that since the method was defined without an access modifier, the compiler will automatically insert the public access modifier.
  - Without an explicit reference to the name of the interface, the code will not compile (getJumpHeight()), even if you to call it from a class that implements Hop.
  - The static methods are not inherited by a class implementing the interface! As they would if the method were defined in a parent class (extends).
  - Compiling code example:
    `
    public class Bunny implements Hop {
      public void printDetails() {
        return System.out.println(Hop.getJumpHeight());
      }
    }
    `
  - Java "solved" the multiple inheritance problem of static interface methods by not allowing them to be inherited.
  - This applies to both subinterfaces and classes that implement that interface! No one inherits the static methods. For example, a class that implements two 
  interfaces containing static methods with the same signature will still compile.

* New Java 9 inteface methods bellow (p.522-524)
** Introducing private Interface Methods
  - They cannot be used outside the interface definition.
  - They also cannot be used in static interface methods without a static method modifier.
  - They were added on Java 9 to be used to reduce code duplication. For example, if we had a logger piece of code that needed to be inside a bunch of default methods, 
  prior to 9 we would need to duplicate the code in the methods, but since 9 we can have private methods with this kind of specific code that can be reused.
  - Example of working code:
    `
    public interface Schedule {
      default void wakeUp() { checkTime(7); }
      default void haveBreakfast() { checkTime(9); }
      default void haveLunch() { checkTime(12); }
      default void workOut() { checkTime(18); }
      private void checkTime(int hour) {
        if (hour > 17) {
          System.out.println("Late!");
        } else {
          System.out.println("You have " + (17-hour) + " hours left to make the appointment.");
        }
      }
    }
    ` 
  - Private Interface Method Definition Rules:
    1. A private interface method must be marked with the private modifier and include a method body.
    2. A private interface method may be called only by default and private (non-static) methods within the interface definition.
  - They look a lot like instance methods within a class. Like private methods in a class, they cannot be declared abstract since they are not inherited.

** Introducing private static Interface Methods
  - Has the same purpose as private methods, to reduce duplication, but this time is meant to reduce duplication inside static methods within the interface declaration.
  - But remember, private static interface methods can also be accessed by default and private methods that are non-static.
  - Example of working code:
    `
    public interface Swim {
      private static void breathe(String type) {
        System.out.println("Inhale");
        System.out.println("Performing stroke: " + type);
        System.out.println("Exhale");
      }
      static void butterfly() { breathe("butterfly"); }
      public static void freestyle() { breathe("freestyle"); }
      default void backstroke() { breathe("backstroke"); }
      private void breaststroke() { breathe("breaststroke"); }
    }
    ` 
  - Private Static Interface Method Definition Rules:
    1. A private static interface method must be marked with the private and static modifiers and include a method body.
    2. A private static interface method may be called only by other methods within the interface definition.
  - They can be called by any methods from within the interface definition. On the other hand, private static methods cannot call default or private methods, this would 
  be like trying to access an instance method from a static method in a class.
  - Why mark these methods with private?
    - The answer is to improve encapsulation and reducing duplication, as we might not want these methods exposed outside the interface declaration.
    - Encapsulation and security work best when the outside caller knows as little as possible about the internal implementation of a class or an interface.

** Reviewing Interface Members
  - Interface Member Access:
   ________________________________________________________________________________________________________________________________________________________________
  |                          Accessible from default and   Accessible from static methods     Accessible from instance methods   Accessible outside the interface  |
  |                          private methods within the    within the interface definition?   implementing or extending the      without an instance of interface? |
  |                          interface definition?                                            interface?                                                           |
  |________________________________________________________________________________________________________________________________________________________________|
  |  Constant variable       Yes                           Yes                                Yes                                Yes                               | 
  |________________________________________________________________________________________________________________________________________________________________|     
  |  abstract method         Yes                           No                                 Yes                                No                                |
  |________________________________________________________________________________________________________________________________________________________________|
  |  default method          Yes                           No                                 Yes                                No                                |
  |________________________________________________________________________________________________________________________________________________________________|
  |  private method          Yes                           No                                 No                                 No                                |
  |________________________________________________________________________________________________________________________________________________________________|
  |  static method           Yes                           Yes                                Yes                                Yes                               |
  |________________________________________________________________________________________________________________________________________________________________|
  |  private static method   Yes                           Yes                                No                                 No                                |
  |________________________________________________________________________________________________________________________________________________________________|
  
  - The first two collumns are about accessing from within the interface definition, the last two are about accessing from outside the interface.
  - Recall what you know about class access modifiers and private members, instance methods can access static members within the class, but static members cannot access 
  intance methods without a reference to the instance. Also, private and static members are never inherited, so they are never accessible directly by a class 
  implementing an interface.

** Abstract classes vs. Interfaces
  - A key distinction is that interfaces do not implement constructors and are not part of the class hierarchy. While a class can implement multiple interfaces, it can 
  only directly extend a single class.
