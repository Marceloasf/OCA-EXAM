** Chapter 13 - Annotations

* Annotations
  - Describe the purpose of annotations and typical usage patterns 
  - Apply annotations to classes and methods
  - Describe commonly used annotations in the JDK
  - Declare custom annotations
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** p.554-557
** Introducing Annotations
  - Annotations are all about METADATA. 
  - Metadata is data that provides information about other data. For example, 'attribute data' is the type of data that includes transactional info 
  that makes up the object and its content. On the other hand, 'metadata' includes the rules, properties or relationships surrounding the object.
  - These metadata rules describe information about the object, but are not part of him.
  - While annotations allow you to insert rules around data, it does not mean the values for these rules need to be defined in the code, aka 'hard coded',
  you can define the rules and relationships in the code but read the values from elsewhere, such as from a configuration file or database.

* Purpose of Annotations
  - The purpose of an annotation is to assign metadata attributes to classes, methods, variables and other Java types. 
  - Annotations start with the at (@) symbol and can contain attribute/value pairs called 'elements'.
  - Example of an annotation: `@ZooAnimal public class Peacock extends Bird { }`
  - This example brings us to the first rule about annotations: `annotations function a lot like interfaces.`
  - Because in this example annotations allow us to mark a class as a ZooAnimal without changing its inheritance structure.
  - If they are similar to interfaces, why we just don't use them? While interfaces can be applied only to classes, annotations can be applied to any 
  declaration including classes, methods, expressions and even other annotations. Also, unlike interfaces, annotations allow us to pass a set of values 
  where they are applied.
  - Consider the following example:
    `
    public class Veterinarian {
      @ZooAnimal(habitat="Infirmary") private Lion sickLion;

      @ZooAnimal(habitat="Safari") private Lion healthyLion;

      @ZooAnimal(habitat="Special Enclosure") private Lion blindLion;
    }
    `
  - The habitat value is part of the type declaration of each variable, not an individual object. This class defines an habitat for each Lion, even if a  
  Lion variable points to another object, it would still have the same habitat value.
  - This example brings us to the second rule about annotations: `annotations establish relationships that make it easier to manage data about our application.`
  - The third rule about annotations is: `an annotation ascribes custom information on the declaration where it is defined.`. The same annotation can often be 
  applied to completely unrelated classes or variables.
  - There is one final rule about annotations you should be familiar with: `annotations are optional metadata and by themselves do not do anything.`. This means 
  that you can take a project filled with thousand of annotations and remove all of them, and it will still compile and run, albeit with potetially different 
  behavior at runtime.
  - This last rule might seem a little counterintuitive at first, but it refers to the fact that annotations aren't utilized where they are defined. It's up to the 
  rest of the application, or more likely the underlying framework, to enforce or use annotations to accomplish tasks.
  - While an annotation can be removed from a class and it will still compile, the opposite is not true; adding an annotation can trigger a compiler error. As we 
  will see in this chapter, the compiler validates that annotations are properly used and include all required fields, like @FunctionalClass or @SafeVarargs.
  - Annotations, just like methods or fields, can be inherited between class hierarchies. The annotation can be overridden in case the child class has the annotation. 
  Because there is no multiple inheritance in Java, annotations on interfaces cannot be inherited.

* Note for the exam: You need to know how to define your own custom annotations, how to apply annotations properly and how to use common annotations. Writing code 
that processes or enforces annotations is not required for the exam.

** p.558-562
** Creating Custom Annotations
  - We use the `@interface` annotation (all lowercase) to declare an annotation. Yes, we use an annotation to create an annotation.
  - Like classes and interfaces, they are commonly defined in their own file as a top-level type, although they can be defined inside a class declaration like an 
  inner class.
  - Example of an interface declaration: `public @interface Exercise { }`
  - This annotation example defined above, is referred as a 'marker annotation', since it does not contain any elements.
  - To apply this interface, you just need to use the at symbol (@):
    `
    @Exercise() public class Cheetah { }

    @Exercise
    public class ZooEmployee { }
    `
  - When using a marker annotation, the parentheses are optional, because they don't contain any values.
  - If an annotation is declared on a line by itself, then it applies to the next non-annotation type found on the proceeding lines. This applies even when there are 
  multiple annotations present. For example:
    `
    @Scaley       @Flexible
      @Food("insect") @Food("rodent")     @FriendlyPet
    @Limbless public class Snake { }
    `
  - Regardless of where they are, all of the annotations apply to Snake. As with other declarations in Java, spaces and tabs between elements are ignored.
  - Whether you put annotations on the same line as the type they apply to or on separate lines is a matter of style, either is acceptable.
  - Annotations are case sensitive, like classes and interfaces names, it is a common practice to have them start with an uppercase letter, although is not required.
  - There are some annotations that can be applied more than once, like @Food, we will cover them later in this chapter.

* Specifying a Required Element
  - An annotation element is an attribute that stores values about the particular usage of an annotation. For example, lets make @Exercise more useful:
    `
    public @interface Exercise {
      int hoursPerDay();
    }
    ` 
  - hoursPerDay may look a lot like an abstract method, although we're calling it an element (or attribute). Remember, annotations have their roots in interfaces, so 
  behind the scenes, the JVM is creating elements as interface methods and annotations as implementations of these interfaces, you don't need to worry about this 
  details for the exam. The compiler does it all for you too.
  - Adding elements on an annotation changes our usage:
    `
    @Exercise(hoursPerDay=3) public class Cheetah { } // COMPILES

    @Exercise hoursPerDay=3 public class Cheetah { } // DOES NOT COMPILE. Remember, parentheses are optional only if no required values are included.  

    @Exercise public class Cheetah { } // DOES NOT COMPILE. The hoursPerDay is a required value. While the annotation itself is optional,
                                       //                   the compiler still cares that they are used correctly.
    `
  - When declaring an annotation, any element without a default value is considered required.

* Providing an Optional Element
  - For an element to be optional, rather than required, it must include a default value. For example:
  `
    public @interface Exercise {
      int hoursPerDay();
      int startHour() default 6;
    }
  `
  - Next, let's apply the updated annotation to our classes:
    `
    @Exercise(hoursPerDay=3, startHour=5) public class Cheetah { } // COMPILES

    @Exercise(hoursPerDay=3) public class Cheetah { } // COMPILES. It will be instantiated with the default value of 6.

    @Exercise(hoursPerDay=3, startHour="5") public class Cheetah { } // DOES NOT COMPILE. It defines a value that is incompatible with the int type of startHour.
    `
  - When we have more than one element value within an annotation, we separate them by a comma (,).
  - Each element is written using the syntax elementName=elementValue. It's like a shorthand for a Map.
  - The order of each element does not matter. 

* Defining a Default Element Value
  - The default value of an annotation element cannot be just any value. Similar to case statement values, the default value of an annotation must be a non-null 
  constant expression. Example: 
    `
    public @interface BadAnnotation {
      String name() default new String(""); // DOES NOT COMPILE. It does not defines a constant expression.
      String address() default ""; // COMPILES
      String title() default null; // DOES NOT COMPILE. Is null..
    }
    `
  
* Selecting an Element Type
  - An annotation element cannot be declared with just any type, similar to a default element value.
  - It must be a primitive type, a String, a Class (type Class), an enum, another annotation or an array of any of these types.
  - For example:
    `
    public class Bear { }

    public enum Size { SMALL, MEDIUM, LARGE }

    public @interface Panda {
      Integer height();   // DOES NOT COMPILE. While primitives types like int and long are supported, wrapper classes like Integer and Long are not.
      String[][] generalInfo();   // DOES NOT COMPILE. The type String[] is supported, as it is an array of String values, but String[][] is not.
      Bear friendlyBear();    // DOES NOT COMPILE. The type of this element is Bear (not Class). Even if Bear were changed to an interface, would still not compile.
      Size size() default Size.SMALL;   // COMPILES
      Exercise exercise() default @Exercise(hoursPerDay=2);   // COMPILES
    }
    `

* Applying Element Modifiers
  - Like interface abstract methods, annotation elements are implicitly abstract and public, whether you declare them that way or not. Example:
    `
    public @interface Fluffy {
      int cuteness();   // COMPILES
      public abstract int softness() default 11;   // COMPILES
      protected String material();   // DOES NOT COMPILE. 
      private String friendly();   // DOES NOT COMPILE. The access modifier on both material() and friendly() conflicts with the elements being implicitly public.
      final boolean isBunny();   // DOES NOT COMPILE. Like abstract methods, it cannot be marked final.
    }
    ` 

* Adding a Constant variable
  - Annotations can include constant variables that can be accessed by other classes without actually creating the annotation. Example of an annotation constant:
    `
    public @interface ElectricitySource { // This @interface compiles normally.
      public int voltage();
      int MIN_VOLTAGE = 2;
      public static final int MAX_VOLTAGE = 18;
    } 
    ` 
  - Just like interface variables, annotation variables are implicitly public, static and final. These constant variables are not considered elements. For example, 
  marker annotations can contain constants.

** p.563-568
** Applying annotations
  - Let's discuss other ways of applying annotations.
  - Annotations can be applied to any Java declaration including the following:
    - Classes, interfaces, enums and modules
    - Variables (static, instance and local)
    - Methods and constructors
    - Method, constructor and lambda parameters
    - Cast expressions
    - Other annotations
  - The following example compiles, assuming the annotations referenced in it exist:
    `
    @FunctionalInterface interface Speedster {
      void go(String name);
    }

    @LongEars
    @Soft @Cuddly public class Rabbit {
      @Deprecated public Rabbit(@NotNull Integer size) { }

      @Speed(velocity="fast") public void eat(@Edible String input) {
        @Food(vegetarian=true) String m = (@Tasty String) "carrots";

        Speedster s1 = new @Racer Speedster() {
          public void go(@FirstName @NotEmpty String name) {
            System.out.print("Start!" + name);
          }
        };

        Speedster s2 = (@Valid String n) -> System.out.print(n);
      }
    }
    `
  - When applying an annotation to an expression, a cast operation including the Java type is required. On the line of declaration of the local variable 'String m', 
  the expression was cast to String and the annotation @Tasty was applied to the type.
  - Remember when mixing required and optional elements: `to use an annotation, all required values must be provided`. While an annotation may have many elements, values 
  are required only for ones without default values.
    `
    public @interface Swimmer {
      int armLength = 10; // CONSTANT, it cannot be included in an annotation (when applying her).
      String stroke(); // REQUIRED
      String name(); // REQUIRED
      String favoriteStroke() default "Backstroke"; // OPTIONAL
    }
    `
* Creating a value() Element
  - You may have seen an annotation with a value, written without the elementName. The following syntax is valid under the right condition:
    `@Injured("Broken Tail") public class Monkey { }`
  - This is considered a shorthand or abbreviated annotation notation. An annotation must adhere to the following rules to be used without a name:
    1. The annotation declaration must contain an element named value(), which may be optional or required.
    2. The annotation declaration must not contain any other elements that are required.
    3. The annotation usage must not provide values for any other elements.
  - For example:
    `
    public @interface Injured {
      String veterinarian() default "unassigned";
      String value() default "foot"; // VALID
      int age() default 1;
    }

    public abstract class Elephant {
      @Injured("Legs") public void fallDown() { } // Annotation value goes to the element value()
      @Injured(value = "Legs") public abstract int trip();
      @Injured String injuries[];
    }
    `
  - The usage in the first two annotation usages are equivalent, as the compiler will convert the shorthand form to the long form with the value() element name.
  * Good coding practice note: Typically, the value() of an annotation should be related to the name of the annotation. In our previous example, @Injured was the 
  annotation name and the value() referred to the item that was impacted. This is especially important since all shorthand elements use the same element name.
  - For the exam, make sure that if the shorthand notation is used, then there is an element named value(). Also, check if there are no other required elements. 
  For example the following declarations cannot be used with a shorthand annotation:
    `
    public @interface Sleep {
      int value();
      String hours(); // Even with a value() element, it cannot be used, since there are two required elements declared. 
    }

    public @interface Wake {
      String hours(); // Not named value()
    }
    `
  - Likewise, the following annotation is not valid as it provides more than one value:
    `@Injured("Fur", age=2) public class Bear {} // DOES NOT COMPILE!`
  
* Passing an Array of Values
  - Annotations support a shorthand notation for providing an array that contains a single element. For example:
    `
    public @interface Music {
      String[] genres();
    }
    `
  - If we want to provide only one value to the array, we have a choice of two ways to write the annotation. Either of the following is correct:
    `
    public class Giraffe {
      @Music(genres={"Rock and roll"}) String mostDisliked;
      @Music(genres="Classical") String favorite;
    }
    `
  - The first usage is considered the regular form. The second annotation is the shorthand notation.
  - Keep in mind that this is still providing a value for an array element; the compiler is just inserting the missing array braces for you.
  - This notation can be used only if the array is composed of a single element. For example, only one of the following compiles:
    `
    public class Reindeer {
      @Music(genres="Blues", "Jazz") String favorite; // DOES NOT COMPILE, more than one value
      @Music(genres=) String mostDisliked; // DOES NOT COMPILE, array without any values
      @Music(genres=null) String other; // DOES NOT COMPILE, array without any values
      @Music(genres={}) String alternative; // COMPILES, an array with no elements is still a valid array
    }
    `
  - Remember that List or Collection are not in the list of supported element types for annotations.
  - We can combine shorthand notations! For example, combine a shorthand notation value() and an array notation. For example, the following annotations are valid:
    `
    // Rhythm single element is String[] value();
    public class Capybara {
      @Rhythm(value={"Swing"}) String favorite;
      @Rhythm(value="R&B") String secondFavorite;
      @Rhythm({"Classical"}) String mostDisliked;
      @Rhythm("Country") String lastDisliked;
    }
    `  
